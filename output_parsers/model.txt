content = """WHEN TO USE JSON vs PYDANTIC STRUCTURED OUTPUT (REAL-LIFE GUIDE)

This file explains when to use:
1. JsonOutputParser
2. PydanticOutputParser (structured output)

--------------------------------------------------
1. JsonOutputParser — WHEN & WHY
--------------------------------------------------

WHAT IT IS:
- Ensures the LLM returns valid JSON
- Does NOT enforce field names or schema
- Returns a Python dict

WHEN TO USE:
- Exploratory or flexible data
- Content generation
- When structure may change
- When you don't care about strict validation

REAL-LIFE EXAMPLES:

Example 1: Chatbot facts
Prompt: "Give me 5 facts about black holes"
Output can be:
{
  "facts": [...]
}
or
{
  "points": [...]
}

Both are acceptable.

Example 2: Brainstorming ideas
- Marketing ideas
- Blog outlines
- Feature suggestions
Structure is not fixed.

Example 3: LLM as a creative assistant
- Summaries
- Notes
- Learning explanations

WHY JSON IS ENOUGH:
- You just need machine-readable data
- No hard failure if keys change
- Faster to prototype

--------------------------------------------------
2. PydanticOutputParser — WHEN & WHY
--------------------------------------------------

WHAT IT IS:
- Enforces strict schema
- Validates data types & constraints
- Returns a typed Python object

WHEN TO USE:
- Production systems
- APIs
- Databases
- Business logic
- Any place where bad data = bug

REAL-LIFE EXAMPLES:

Example 1: User profile creation
Person:
- name: string
- age: integer > 18
- city: string

If LLM outputs age = 15 → ERROR
This prevents invalid users entering system.

Example 2: Resume parsing
Resume:
- name
- email
- years_of_experience
- skills (list)

Missing field? → ERROR
Wrong type? → ERROR

Example 3: Order processing
Order:
- product_id
- quantity > 0
- price > 0

LLM mistake here could cause money loss.
Pydantic protects you.

WHY PYDANTIC IS REQUIRED:
- Guarantees correctness
- Prevents silent failures
- Safe to pass into downstream code
- Easy debugging

--------------------------------------------------
3. DECISION RULE (MOST IMPORTANT)
--------------------------------------------------

Ask yourself ONE question:

"Will my Python code BREAK if this output is wrong?"

If NO → Use JsonOutputParser
If YES → Use PydanticOutputParser

--------------------------------------------------
4. QUICK COMPARISON TABLE
--------------------------------------------------

JsonOutputParser:
- Flexible
- No validation
- Best for creativity
- Prototype friendly

PydanticOutputParser:
- Strict
- Validated
- Best for production
- Bug resistant

--------------------------------------------------
5. COMMON MISTAKES
--------------------------------------------------

Mistake 1:
Using JsonOutputParser for production APIs

Mistake 2:
Using Pydantic for brainstorming (overkill)

Mistake 3:
Trusting LLM without validation

--------------------------------------------------
FINAL RULE OF THUMB
--------------------------------------------------

JSON = "Readable"
PYDANTIC = "Reliable"

If data flows into:
- database
- API
- billing
- auth
- automation

→ ALWAYS use Pydantic

END OF FILE
"""
